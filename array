// Code generated by go generate on {{ .Timestamp }}
package {{ .PackageName }}


import (
{{ range $_, $package := .Imports }}
	"{{ $package }}"
{{ end }} )

{{$Types := .Types}}

{{ range $label, $type := $Types }}
// Array{{ $label }}
type Array{{ $label }} interface {
	First() Result{{$label}}
	Slice() []{{$type}}
	Each(func({{ $type }}))
	Concat(Array{{$label}}) array{{$label}}
	Filter(func({{ $type }})bool) array{{$label}}
	Find(func({{ $type }}) bool) Result{{ $label }} 
{{ range $l, $t := $Types }}
	Map{{ $l }}(func({{ $type }}) {{ $t }}) array{{ $l }}
	Reduce{{ $l }}(func({{ $type }}, int, Array{{ $label }}) {{ $t }}, {{ $t }}) {{ $t }}
{{ end }} 
}
{{ end }}



{{ range $label, $type := $Types }}

// array{{ $label }} is a type alias for []{{$type}}
type array{{ $label }} []{{$type}}

// Array{{$label}} makes an arry off of its arguments of type {{$type}} 
func Array{{$label}}From(a ...{{$type}}) array{{$label}} {
	return array{{$label}}(a)
}

// First with array{{$label}} receiver
// returns first element in a Result{{$label}} container
func (a array{{$label}}) First() Result{{$label}} {
	if len(a) > 0 {
		return Ok{{$label}}(a[0])
	}
	return Err{{$label}}("Out Of Bound Array Access")
}

// Slice with array{{$label}} receiver
// returns itself as []{{$type}}
func (a array{{$label}}) Slice() []{{$type}} {
	return []{{$type}}(a)
}

// Each with array{{$label}} receiver
// applies its function argument on each item of the array
func (a array{{ $label }}) Each(f func({{ $type }})) {
	for _, e := range a { f(e) }
}

// Concat with array{{$label}} receiver
// returns the concatenation of itself and  its argument array 
func (a array{{ $label }}) Concat(xs Array{{$label}}) array{{ $label }} {
	return array{{$label}}(append(a.Slice(), xs.Slice()...))
}

// Filter with array{{$label}} receiver
// returns a filtered array 
func (a array{{ $label }}) Filter(f func({{ $type }}) bool) array{{ $label }} {
	r := make([]{{ $type }}, 0)

	a.Each(func(e {{ $type }}) {
		if f(e) {
			r = append(r, e)
		}
	})

	return Array{{ $label }}From(r...)
}

// Find with array{{$label}} receiver
// returns a Result{{$label}} as soon as item is found 
func (a array{{ $label }}) Find(f func({{ $type }}) bool) Result{{ $label }} {
	for _, e := range a.Slice() {
		if f(e) {
			return Ok{{$label}}(e)
		}
	}
	return Err{{$label}}("{{$label}} Not Found")
}

{{ range $l, $t := $Types }}
// Map with array{{$label}} receiver
// returns an array{{$l}} resulting from apllying its function argument
// to every items of the receiver
func (a array{{ $label }}) Map{{ $l }}(f func({{ $type }}) {{ $t }}) array{{ $l }} {
	var r = make(array{{$l}}, len(a))
	for i, e := range a { r[i] = f(e) }
	return array{{$l}}(r)
}

// Reduce with array{{$label}} receiver
func (a array{{ $label }}) Reduce{{ $l }}(f func({{ $type }}, int, Array{{ $label }}) {{ $t }}, initial {{ $t }}) {{ $t }} {
	var r {{$t}} = initial
	for i, e := range a { 
		r = f(e, i, a)
	}
	return r
}



{{ end }} // end of {{$label}}

{{ end }} // end of implements



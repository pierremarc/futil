// Code generated by go generate on {{ .Timestamp }}
package {{ .PackageName }}


import (
	"errors"
{{ range $_, $package := .Imports }}
	"{{ $package }}"
{{ end }} )
{{$Types := .Types}}

{{ range $label, $type := $Types }}
// Result{{ $label }}
type Result{{ $label }} interface {
	Map(func({{ $type }}))
	FoldF(func(error), func({{ $type }}))
{{ range $l, $t := $Types }}
	Map{{ $l }}(func({{ $type }}) {{ $t }}) Result{{ $l }}
	Fold{{ $l }}({{ $t }}, func({{ $type }}) {{ $t }}) {{ $t }}
	Fold{{ $l }}F(func(error) {{ $t }}, func({{ $type }}) {{ $t }}) {{ $t }}
{{ end }} 
}
{{ end }}


{{ range $label, $type := $Types }}
// Result{{ $label }}From builds a result type from a function returning
// ({{ $type }}, err)
// e.g.: r :=  Result{{ $label }}From(myfunc(args))
func Result{{ $label }}From(v {{ $type }}, err error) Result{{ $label }} {
	if err != nil {
		return Err{{ $label }}(err)
	}
	return Ok{{ $label }}(v)
}
{{ end }}

{{ range $label, $type := $Types }}

// err{{ $label }} implements Result{{ $label }} for a failed result
type err{{ $label }} struct{
	left error
}

// Err{{ $label }}(error  | string) makes a new err{{ $label }}
// from an error or a string.
func Err{{ $label }}(err interface{}) err{{ $label }} {
	switch err.(type) {
		case string : return err{{ $label }}{errors.New(err.(string))}
		case error : return err{{ $label }}{err.(error)}
	} 
	return err{{ $label }}{errors.New("Err{{ $label }} called with something else than string or error")}
}

// Map with err{{ $label }} receiver is a noop
func (e err{{ $label }}) Map(f func({{ $type }})) {}

// FoldF with err{{ $label }} applies it's first argument
// function on its error state
func (e err{{ $label }}) FoldF(l func(e error), r func({{ $type }})) { l(e.left) }

{{ range $l, $t := $Types }}
// Map{{ $l }} with err{{ $label }} receiver
// returns a newly built err{{ $label }} with same error.
func (e err{{ $label }}) Map{{ $l }}(f func(v {{ $type }}) {{ $t }}) Result{{ $l }} {
	return Err{{ $l }}(e.left)
}
// Fold{{ $l }} with err{{ $label }} receiver
// returns its first argument.
func (e err{{ $label }}) Fold{{ $l }}(a {{ $t }}, f func(v {{ $type }}) {{ $t }}) {{ $t }} {
	return a
}
// Fold{{ $l }}F with err{{ $label }} receiver
// returns the result of its first argument applied to the result error state.
func (e err{{ $label }}) Fold{{ $l }}F(a func(error) {{ $t }}, f func({{ $type }}) {{ $t }}) {{ $t }} {
	return a(e.left)
}
{{ end }} // end of nones

// ok{{ $label }} implements Result{{ $label }} for a successful result
type ok{{ $label }} struct {
	right {{ $type }}
}

// Ok{{ $label }} returns a successful result with value v of type {{ $type }} 
func Ok{{ $label }}(v {{ $type }}) ok{{ $label }} {
	return ok{{ $label }}{v}
}
// Map{{ $label }} with ok{{ $label }} receiver
// applies its function argument on hold value 
func (s ok{{ $label }}) Map(f func({{ $type }})) { f(s.right) }

// FoldF{{ $label }} with ok{{ $label }} receiver
// applies its second function argument on hold value 
func (s ok{{ $label }}) FoldF(l func(error), r func({{ $type }})) { r(s.right) }

{{ range $l, $t := $Types }}
// Map{{ $l }} on ok{{ $label }} receiver
// applies its function arguments on hold value and returns an ok{{ $l }}
func (s ok{{ $label }}) Map{{ $l }}(f func({{ $type }}) {{ $t }}) Result{{ $l }} {
	return Ok{{ $l }}(f(s.right))
}

// Fold{{ $l }} on ok{{ $label }} receiver
// applies its second function arguments on hold value and returns an {{ $type }}
func (s ok{{ $label }}) Fold{{ $l }}(a {{ $t }}, f func({{ $type }}) {{ $t }}) {{ $t }} {
	return f(s.right)
}

// Fold{{ $l }}F on ok{{ $label }} receiver
// applies its second function arguments on hold value and returns an {{ $type }}
func (s ok{{ $label }}) Fold{{ $l }}F(a func(error) {{ $t }}, f func({{ $type }}) {{ $t }}) {{ $t }} {
	return f(s.right)
}
{{ end }} // end of oks

{{ end }} // end of everything

